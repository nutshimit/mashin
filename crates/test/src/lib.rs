use aws_sdk_s3::model::BucketCannedAcl;
use mashin_sdk::{
    ext::{
        anyhow::{anyhow, bail},
        async_trait::async_trait,
        serde::{ser::SerializeStruct, Deserialize, Serialize},
        serde_json::{self, Value},
        tokio,
    },
    resource, Provider, ProviderState, Resource, ResourceAction, ResourceDiff, ResourceResult,
    Result, Urn,
};

#[macro_export]
macro_rules! log {
	($level:tt, $patter:expr $(, $values:expr)* $(,)?) => {
		log::$level!(
			target: "mashin::core",
            $patter $(, $values)*
		)
	};
}

use std::sync::Arc;
use std::{
    alloc::{dealloc, Layout},
    str::FromStr,
};
use std::{any::Any, ptr};

#[derive(Default, Clone, Serialize, Deserialize)]
pub struct AwsConfig {
    aws_key: Option<String>,
}

#[derive(Default, Clone)]
pub struct AwsState {
    aws_client: Option<Arc<aws_sdk_s3::Client>>,
}

#[derive(Default)]
pub struct AwsProvider {
    __config: AwsConfig,
    __state: Box<ProviderState>,
}

#[async_trait]
impl Provider for AwsProvider {
    async fn init(&mut self) -> Result<()> {
        let config = aws_config::load_from_env().await;
        let client = aws_sdk_s3::Client::new(&config);

        let default_state = AwsState {
            aws_client: Some(Arc::new(client)),
        };
        self.__state.put(default_state);

        Ok(())
    }

    fn state(&self) -> &ProviderState {
        self.__state.as_ref()
    }

    // this can be generated by the macro
    fn __from_current_state(&self, urn: &Urn, state: &Value) -> Result<Box<dyn Resource>> {
        let raw_urn = urn.nss().split(":").collect::<Vec<_>>()[1..].join(":");
        // expect; s3:bucket
        let module_urn = raw_urn.to_lowercase();
        // resource name
        let name = urn
            .q_component()
            .ok_or(anyhow!("expect valid urn (name not found)"))?;

        // map module dynamicly
        match module_urn.as_str() {
            "s3:bucket" => Ok(Bucket::from_current_state(name, &urn.to_string(), state)?),
            _ => bail!("invalid URN"),
        }
    }
}

#[derive(Default, Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct BucketConfig {
    #[serde(default)]
    acl: Option<String>,
    #[serde(default)]
    woot: Option<bool>,
}

#[resource]
pub struct Bucket {
    url: Option<String>,

    // this should be injected by the macro
    #[sensitive]
    __name: String,
    #[sensitive]
    __config: BucketConfig,
    #[sensitive]
    __urn: String,
}

#[async_trait]
impl Resource for Bucket {
    async fn get(&mut self, provider_state: &ProviderState) -> Result<()> {
        log!(info, "Refreshing {}", self.__urn);

        let state = provider_state
            .try_borrow::<AwsState>()
            .ok_or(anyhow!("state not initialized"))?;
        let client = state.aws_client.as_ref().ok_or(anyhow!("invalid state"))?;

        let bucket_exist = client
            .head_bucket()
            .bucket(&self.__name)
            .send()
            .await
            .is_ok();

        if bucket_exist {
            self.url = Some(format!("http://{}.s3.amazonaws.com/", &self.__name));
        }

        Ok(())
    }

    async fn update(&mut self, provider_state: &ProviderState, diff: &ResourceDiff) -> Result<()> {
        // we should update ACL
        if diff.has_change("config.acl") {
            println!("SHOULD UPDATE ACL");
        }

        Ok(())
    }

    async fn delete(&mut self, provider_state: &ProviderState) -> Result<()> {
        Ok(())
    }

    async fn create(&mut self, provider_state: &ProviderState) -> Result<()> {
        let state = provider_state
            .try_borrow::<AwsState>()
            .ok_or(anyhow!("state not initialized"))?;

        let client = state.aws_client.as_ref().ok_or(anyhow!("invalid user"))?;

        let cfg = aws_sdk_s3::model::CreateBucketConfiguration::builder()
            .location_constraint(aws_sdk_s3::model::BucketLocationConstraint::UsEast2)
            .build();

        let acl = self
            .__config
            .acl
            .as_ref()
            .map(|a| BucketCannedAcl::from_str(a).expect("valid acl"))
            .unwrap_or(BucketCannedAcl::Private);

        let bucket = client
            .create_bucket()
            .create_bucket_configuration(cfg)
            .acl(acl)
            .bucket(&self.__name)
            .send()
            .await?;

        self.url = bucket.location().map(|s| s.to_string());

        Ok(())
    }

    // these fns can be generated with the macro
    fn __default_with_params(name: &str, urn: &str) -> Self
    where
        Self: Sized,
    {
        Self {
            __name: name.to_string(),
            __urn: urn.to_string(),
            ..Default::default()
        }
    }

    fn __set_config_from_value(&mut self, config: &Value) {
        self.__config = serde_json::from_value::<BucketConfig>(config.clone()).unwrap_or_default();
    }
}

#[no_mangle]
pub extern "C" fn new() -> *mut AwsProvider {
    let runtime = tokio::runtime::Runtime::new().expect("New runtime");
    let mut provider = AwsProvider::default();
    runtime.block_on(provider.init()).expect("valid provider");
    let static_ref = Box::new(provider);
    Box::into_raw(static_ref)
}

#[no_mangle]
pub extern "C" fn run(
    handle_ptr: *mut AwsProvider,
    urn_ptr: *mut Urn,
    resource_state_ptr: *mut Value,
    config_ptr: *mut Value,
    action_ptr: *mut ResourceAction,
    maybe_diff: *mut ResourceDiff,
) -> *mut ResourceResult {
    let runtime = tokio::runtime::Runtime::new().expect("New runtime");

    // grab current provider
    assert!(!handle_ptr.is_null());
    let provider = unsafe {
        let provider = &mut *handle_ptr;
        provider
    };
    let provider_state = provider.state();

    // resource URN
    let urn = unsafe { &*urn_ptr };
    // resource config (sent from JS runtime)
    let config = unsafe { &*config_ptr };

    // FIXME: should be dropped as we drop the ref (clone)
    let resource_state = unsafe { &*resource_state_ptr };
    let action = unsafe { &*action_ptr };

    let mut resource = provider
        .__from_current_state(urn, resource_state)
        .expect("Valid resource");

    // grab the state before applying our values
    resource.__set_config_from_value(config);

    runtime
        .block_on(async {
            match action {
                ResourceAction::Update => {
                    assert!(!maybe_diff.is_null());
                    let diff = unsafe {
                        let diff = &mut *maybe_diff;
                        diff
                    };
                    resource.update(provider_state, diff)
                }
                ResourceAction::Create => resource.create(provider_state),
                ResourceAction::Delete => resource.delete(provider_state),
                ResourceAction::Get => resource.get(provider_state),
            }
            .await
        })
        .expect("valid execution");

    let state = resource.to_raw_state().expect("valid resource");
    let result = ResourceResult::new(state);
    let static_ref = Box::new(result);
    Box::into_raw(static_ref)
}

#[no_mangle]
pub extern "C" fn drop(handle: *mut AwsProvider) {
    assert!(!handle.is_null());
    unsafe {
        ptr::drop_in_place(handle);
        dealloc(handle as *mut u8, Layout::new::<AwsProvider>());
    }
}

impl Drop for AwsProvider {
    fn drop(&mut self) {
        println!("AWS PROVIDER DROPPED")
    }
}
